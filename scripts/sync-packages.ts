#!/usr/bin/env bun
/**
 * Sync package docs from package repos into this repo's `packages/*.md`.
 *
 * Source-of-truth: each package repo `docs/index.md`
 * Output: this repo `packages/<pkg>.md`
 *
 * @example
 * ```bash
 * bun run sync:packages
 * ```
 */

import { mkdir, writeFile } from "fs/promises";
import { dirname, join } from "path";

export type SyncTarget = Readonly<{
	/**
	 * GitHub repository name under `bunary-dev/` (e.g. `core`, `http`).
	 */
	repo: string;
	/**
	 * Output filename under `packages/` (e.g. `core.md`).
	 */
	outputFileName: string;
	/**
	 * Raw URL to fetch markdown content from.
	 */
	sourceUrl: string;
}>;

/**
 * Deterministic list of package docs we sync (phase 1).
 *
 * Extending this list is the only change needed to sync another package's `docs/index.md`.
 */
export const SYNC_TARGETS: ReadonlyArray<SyncTarget> = Object.freeze([
	{
		repo: "core",
		outputFileName: "core.md",
		sourceUrl: "https://raw.githubusercontent.com/bunary-dev/core/main/docs/index.md",
	},
	{
		repo: "http",
		outputFileName: "http.md",
		sourceUrl: "https://raw.githubusercontent.com/bunary-dev/http/main/docs/index.md",
	},
	{
		repo: "auth",
		outputFileName: "auth.md",
		sourceUrl: "https://raw.githubusercontent.com/bunary-dev/auth/main/docs/index.md",
	},
	{
		repo: "orm",
		outputFileName: "orm.md",
		sourceUrl: "https://raw.githubusercontent.com/bunary-dev/orm/main/docs/index.md",
	},
	{
		repo: "cli",
		outputFileName: "cli.md",
		sourceUrl: "https://raw.githubusercontent.com/bunary-dev/cli/main/docs/index.md",
	},
]);

export type RenderSyncedPackageMarkdownArgs = Readonly<{
	generatorCommand: string;
	sourceUrl: string;
	sourceMarkdown: string;
}>;

/**
 * Render the markdown we commit into `packages/*.md`.
 * Output is deterministic (LF newlines, trailing newline).
 */
export function renderSyncedPackageMarkdown(args: RenderSyncedPackageMarkdownArgs): string {
	const normalizedSource = normalizeNewlines(args.sourceMarkdown).trimEnd();
	const header = [
		"<!--",
		"  AUTO-GENERATED FILE — DO NOT EDIT DIRECTLY.",
		`  Generated by: ${args.generatorCommand}`,
		`  Source: ${args.sourceUrl}`,
		"-->",
		"",
	].join("\n");

	return `${header}${normalizedSource}\n`;
}

function normalizeNewlines(input: string): string {
	return input.replace(/\r\n/g, "\n");
}

export type SyncPackagesOptions = Readonly<{
	/**
	 * Absolute repo root directory. Defaults to `process.cwd()`.
	 */
	repoRootDir?: string;
	/**
	 * Fetch a URL as text. Defaults to `fetch(url).text()`.
	 */
	fetchText?: (url: string) => Promise<string>;
	/**
	 * Write a file (absolute path). Defaults to `fs/promises.writeFile`.
	 */
	writeFile?: (absolutePath: string, content: string) => Promise<void>;
	/**
	 * Ensure a directory exists (absolute path). If omitted, directories are created
	 * only when using the default writer.
	 */
	mkdirp?: (absoluteDir: string) => Promise<void>;
	/**
	 * Which targets to sync. Defaults to `SYNC_TARGETS`.
	 */
	targets?: ReadonlyArray<SyncTarget>;
	/**
	 * If true, throw on the first fetch/write error. If false, log and continue.
	 * Defaults to false (CI drift-check can enforce strictness later).
	 */
	strict?: boolean;
}>;

/**
 * Sync all package docs into `packages/`.
 */
export async function syncPackages(options: SyncPackagesOptions = {}): Promise<void> {
	const repoRootDir = options.repoRootDir ?? process.cwd();
	const targets = options.targets ?? SYNC_TARGETS;
	const strict = options.strict ?? false;

	const fetchText =
		options.fetchText ??
		(async (url: string) => {
			const res = await fetch(url);
			if (!res.ok) {
				throw new Error(`Failed to fetch "${url}" (${res.status} ${res.statusText})`);
			}
			return await res.text();
		});

	const defaultMkdirp = async (absoluteDir: string) => {
		await mkdir(absoluteDir, { recursive: true });
	};

	const mkdirp = options.mkdirp ?? (options.writeFile ? undefined : defaultMkdirp);

	const writer =
		options.writeFile ??
		(async (absolutePath: string, content: string) => {
			await writeFile(absolutePath, content, "utf-8");
		});

	for (const target of targets) {
		let sourceMarkdown: string;
		try {
			sourceMarkdown = await fetchText(target.sourceUrl);
		} catch (error) {
			if (strict) throw error;
			console.warn(
				`⚠️  Skipping "${target.repo}" (failed to fetch ${target.sourceUrl}): ${
					error instanceof Error ? error.message : String(error)
				}`,
			);
			continue;
		}

		const outputMarkdown = renderSyncedPackageMarkdown({
			generatorCommand: "bun run sync:packages",
			sourceUrl: target.sourceUrl,
			sourceMarkdown,
		});

		const outputPath = join(repoRootDir, "packages", target.outputFileName);

		if (mkdirp) {
			await mkdirp(dirname(outputPath));
		}

		await writer(outputPath, outputMarkdown);
	}
}

if (import.meta.main) {
	await syncPackages();
}

